= Contributing
Mitwirken am Projekt _game_ququ
:toc:
:toclevels: 2

Vielen Dank für Ihr Interesse an einer Mitarbeit an diesem Projekt.

Dieses Repository implementiert eine Python-basierte Game-Engine und ein Regel-Framework
für ein Quacks-ähnliches Brettspiel (Runden-/Phasenlogik, Ereigniskarten, Spielerzustände
und ein stetig wachsendes Regelwerk). Die Codebasis ist bewusst auf schrittweise
Korrektheit ausgelegt: kleine, gut überprüfbare Änderungen werden gegenüber
umfangreichen „Alles-auf-einmal“-Umbauten bevorzugt.

== Projektziele

* Bereitstellung einer gut lesbaren und testbaren Regel-Engine
* Explizite Modellierung von Spielzustand und Zustandsübergängen
* Einfache Erweiterbarkeit um neue Regeln, Chips und Ereigniskarten
* Entwicklerfreundliche Konsolenausgaben zur Überprüfung des Spielablaufs

== Grundregeln für Beiträge

=== 1. Pull Requests klein halten

Bevorzugt werden Pull Requests, die genau *eine* klar abgegrenzte Aufgabe erfüllen:

* ein Refactoring
* die Implementierung einer einzelnen Ereigniskarte
* ein Bugfix
* eine Testergänzung
* eine Dokumentationsänderung

Größere oder strukturelle Änderungen bitte *vorab* als Issue oder Discussion vorschlagen.

=== 2. Keine „stillen“ Architekturänderungen

Die Architektur dieses Projekts ist bewusst explizit gestaltet:

* Der Spielzustand wird zentral verwaltet
* Runden und Phasen sind klar sequenziert
* Regeln werden über Dispatch-Tabellen und klar benannte Funktionen umgesetzt

Abweichende Architekturvorschläge sind willkommen, sollten jedoch zuerst in einer
Discussion erläutert werden. Bitte keine grundlegenden Umbauten in einem PR „verstecken“.

=== 3. Determinismus bevorzugen

Wenn neue Logik Zufälligkeit einführt (z. B. Kartenziehen oder Chip-Züge), gilt:

* Es sollte eine klar definierte Möglichkeit zur Initialisierung (Seed) geben, oder
* Es müssen deterministische Hooks für Tests und Debugging vorhanden sein

== Einstieg für neue Mitwirkende

=== 1. Fork und Branch anlegen

* Forken Sie das Repository
* Erstellen Sie einen Feature-Branch von `main`, z. B.:

* `feature/<kurze-beschreibung>`
* `fix/<kurze-beschreibung>`
* `docs/<kurze-beschreibung>`

=== 2. Lokale Entwicklungsumgebung

Dieses Projekt basiert auf Standard-Python.

Empfohlen:
* Python 3.11 oder neuer
* Virtuelle Umgebung

Beispiel:

[source,bash]
----
python -m venv .venv
source .venv/bin/activate
python -m pip install -U pip
----

Falls vorhanden:

[source,bash]
----
pip install -r requirements.txt
----

Falls keine Abhängigkeiten definiert sind, sollte das Projekt mit der
Standardbibliothek lauffähig sein.

=== 3. Ausführen des Spiels

Der Einstiegspunkt ist im README dokumentiert. Typische Varianten:

[source,bash]
----
python main.py
# oder
python -m <paketname>
# oder
python rounds.py
----

Bei Änderungen am Einstiegspunkt bitte das README aktualisieren.

== Woran gearbeitet werden kann

=== Geeignete erste Beiträge

Issues mit den Labels:

* `good first issue`
* `help wanted`

sind bewusst so gestaltet, dass sie einen Einstieg in die Codebasis ermöglichen.

Typische erste Aufgaben:

* Verbesserung oder Vereinheitlichung von Konsolen-/Broadcast-Ausgaben
* Implementierung einzelner Ereigniskarten über Dispatch-Logik
* Ersetzen hart kodierter Fallunterscheidungen durch Tabellen
* Ergänzung kleiner Tests für Randfälle

=== Ereigniskarten – empfohlene Implementierung

Ereigniskarten sollen über Dispatch-Tabellen umgesetzt werden, nicht über
tiefe `if`/`elif`-Ketten.

Grundmuster:

* `event_cards.py` enthält Kartendaten (ID, Titel, Beschreibung)
* Eine Dispatch-Registry ordnet `card_id → Handler-Funktion` zu
* Der Runden-/Phasen-Controller zieht eine Karte und ruft den Handler auf
* Handler sind klein, eindeutig und verändern ausschließlich den `state`

Beim Hinzufügen einer Karte:

. Karte mit stabiler `card_id` im Deck definieren
. Handler-Funktion (`handle_<id>()`) implementieren
. In der Dispatch-Tabelle registrieren
. Mindestens ein reproduzierbares Debug-Szenario oder Test hinzufügen

=== Erwartungen an das Zustandsmodell

Der Spielzustand wird zentral in einer `state`-Struktur (TypedDict-Stil) verwaltet.

Bitte beachten:

* Neue Zustandsfelder an einer klaren, zentralen Stelle definieren
* Hilfsfunktionen wie `ensure_player()` verwenden
* Implizite Zustandsfelder über mehrere Module hinweg vermeiden

Neue Zustandsfelder bitte kurz dokumentieren.

== Coding-Style

* Kleine, klar benannte Funktionen
* Vermeidung von Code-Duplikation
* Sorgfältige Typisierung (z. B. `TypedDict`, `list[int]`)
* Keine unnötigen Abhängigkeiten
* Konsistente und knappe Logging-/Broadcast-Ausgaben

Docstrings:

* Kurz für Hilfsfunktionen
* Strukturiert für „öffentliche“ Engine-Funktionen (Phasen, Handler, Kernlogik)

== Tests

Falls Tests vorhanden sind:

* Bestehende Tests dürfen nicht brechen
* Neue Logik sollte durch Tests ergänzt werden

Falls noch keine Testinfrastruktur existiert:

* Mindestens ein reproduzierbares Szenario pro nicht-trivialem PR bereitstellen
* Alternativ: eine ausführbare Debug-Funktion mit klarer Beschreibung

== Commit- und PR-Richtlinien

=== Commits

Bitte klare, beschreibende Commit-Messages verwenden, z. B.:

* `Implement event card: donations (purple_03)`
* `Refactor: replace hard-coded card branching with dispatch table`
* `Fix: ensure_player initializes desktops`

=== Pull-Request-Beschreibung

Ein PR sollte enthalten:

* Kurze Beschreibung der Änderungen
* Begründung („Warum?“)
* Anleitung zum Testen
* Offene Fragen oder Follow-ups (falls vorhanden)

== Bugs melden / Features vorschlagen

Bitte ein GitHub-Issue erstellen mit:

* Erwartetem vs. tatsächlichem Verhalten
* Reproduktionsschritten
* Relevanten Log-Ausgaben
* Commit-Hash oder Branch (falls zutreffend)

Für größere Änderungen bitte zuerst eine Discussion eröffnen.

== Verhaltensregeln

Sachlicher und respektvoller Umgang ist selbstverständlich.
Technische Diskussionen sollen präzise und lösungsorientiert geführt werden.

== Lizenz

Mit dem Einreichen eines Beitrags erklären Sie sich damit einverstanden,
dass Ihr Beitrag unter der gleichen Lizenz steht wie dieses Repository.
